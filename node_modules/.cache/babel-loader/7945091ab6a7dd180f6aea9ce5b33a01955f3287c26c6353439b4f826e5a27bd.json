{"ast":null,"code":"export const createImage = url => new Promise((resolve, reject) => {\n  const image = new Image();\n  image.addEventListener('load', () => resolve(image));\n  image.addEventListener('error', error => reject(error));\n  image.setAttribute('crossOrigin', 'anonymous'); // needed to avoid cross-origin issues\n  image.src = url;\n});\nexport default async function getCroppedImg(imageSrc, pixelCrop, rotation = 0, flip = {\n  horizontal: false,\n  vertical: false\n}) {\n  const image = await createImage(imageSrc);\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return null;\n  }\n  const rotRad = getRadianAngle(rotation);\n\n  // calculate bounding box of the rotated image\n  const {\n    width: bBoxWidth,\n    height: bBoxHeight\n  } = rotateSize(image.width, image.height, rotation);\n\n  // set canvas size to match the bounding box\n  canvas.width = bBoxWidth;\n  canvas.height = bBoxHeight;\n\n  // translate canvas context to a central location to allow rotating and flipping around the center\n  ctx.translate(bBoxWidth / 2, bBoxHeight / 2);\n  ctx.rotate(rotRad);\n  ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\n  ctx.translate(-image.width / 2, -image.height / 2);\n\n  // draw rotated image\n  ctx.drawImage(image, 0, 0);\n\n  // croppedAreaPixels values are bounding box relative\n  // extract the cropped image using these values\n  const data = ctx.getImageData(pixelCrop.x, pixelCrop.y, pixelCrop.width, pixelCrop.height);\n\n  // set canvas width to final desired crop size - this will clear existing context\n  canvas.width = pixelCrop.width;\n  canvas.height = pixelCrop.height;\n\n  // paste generated rotate image at the top left corner - BUT FIRST, clip to circle if needed\n  // For round crop, we apply a circular clip path\n  const centerX = pixelCrop.width / 2;\n  const centerY = pixelCrop.height / 2;\n  // Assuming aspect ratio is 1 for round crop, so width and height are the diameter\n  const radius = Math.min(pixelCrop.width, pixelCrop.height) / 2;\n  ctx.beginPath();\n  ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n  ctx.closePath();\n  ctx.clip();\n\n  // The data is for a rectangular area. To draw it into the circle,\n  // we might need to draw the original (rotated) image again, but positioned correctly for the clip.\n  // Or, more simply, put the rectangular data onto a temporary canvas\n  // and then draw that temporary canvas onto the clipped main canvas.\n\n  const tempCanvas = document.createElement('canvas');\n  tempCanvas.width = pixelCrop.width;\n  tempCanvas.height = pixelCrop.height;\n  const tempCtx = tempCanvas.getContext('2d');\n  if (!tempCtx) {\n    console.error('Failed to get 2D context from temporary canvas');\n    return null;\n  }\n  tempCtx.putImageData(data, 0, 0); // Place the rectangular crop data onto the temp canvas\n\n  // Draw the content of the temporary canvas onto the main (circularly clipped) canvas\n  // This ensures the previously extracted rectangular data is now drawn within the circle clip\n  ctx.drawImage(tempCanvas, 0, 0, pixelCrop.width, pixelCrop.height);\n\n  // As a blob (which can then be turned into an object URL)\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(file => {\n      if (file) {\n        resolve(URL.createObjectURL(file));\n      } else {\n        reject(new Error('Canvas is empty after attempting to draw cropped circular image.'));\n      }\n    }, 'image/png'); // Output as PNG to support transparency for the circular crop\n  });\n}\nexport function getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\nexport function rotateSize(width, height, rotation) {\n  const rotRad = getRadianAngle(rotation);\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)\n  };\n}","map":{"version":3,"names":["createImage","url","Promise","resolve","reject","image","Image","addEventListener","error","setAttribute","src","getCroppedImg","imageSrc","pixelCrop","rotation","flip","horizontal","vertical","canvas","document","createElement","ctx","getContext","rotRad","getRadianAngle","width","bBoxWidth","height","bBoxHeight","rotateSize","translate","rotate","scale","drawImage","data","getImageData","x","y","centerX","centerY","radius","Math","min","beginPath","arc","PI","closePath","clip","tempCanvas","tempCtx","console","putImageData","toBlob","file","URL","createObjectURL","Error","degreeValue","abs","cos","sin"],"sources":["D:/oosa/oosa_crop_demo/src/cropImage.js"],"sourcesContent":["export const createImage = (url) =>\r\n  new Promise((resolve, reject) => {\r\n    const image = new Image();\r\n    image.addEventListener('load', () => resolve(image));\r\n    image.addEventListener('error', (error) => reject(error));\r\n    image.setAttribute('crossOrigin', 'anonymous'); // needed to avoid cross-origin issues\r\n    image.src = url;\r\n  });\r\n\r\nexport default async function getCroppedImg(\r\n  imageSrc,\r\n  pixelCrop,\r\n  rotation = 0,\r\n  flip = { horizontal: false, vertical: false }\r\n) {\r\n  const image = await createImage(imageSrc);\r\n  const canvas = document.createElement('canvas');\r\n  const ctx = canvas.getContext('2d');\r\n\r\n  if (!ctx) {\r\n    return null;\r\n  }\r\n\r\n  const rotRad = getRadianAngle(rotation);\r\n\r\n  // calculate bounding box of the rotated image\r\n  const { width: bBoxWidth, height: bBoxHeight } = rotateSize(\r\n    image.width,\r\n    image.height,\r\n    rotation\r\n  );\r\n\r\n  // set canvas size to match the bounding box\r\n  canvas.width = bBoxWidth;\r\n  canvas.height = bBoxHeight;\r\n\r\n  // translate canvas context to a central location to allow rotating and flipping around the center\r\n  ctx.translate(bBoxWidth / 2, bBoxHeight / 2);\r\n  ctx.rotate(rotRad);\r\n  ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\r\n  ctx.translate(-image.width / 2, -image.height / 2);\r\n\r\n  // draw rotated image\r\n  ctx.drawImage(image, 0, 0);\r\n\r\n  // croppedAreaPixels values are bounding box relative\r\n  // extract the cropped image using these values\r\n  const data = ctx.getImageData(\r\n    pixelCrop.x,\r\n    pixelCrop.y,\r\n    pixelCrop.width,\r\n    pixelCrop.height\r\n  );\r\n\r\n  // set canvas width to final desired crop size - this will clear existing context\r\n  canvas.width = pixelCrop.width;\r\n  canvas.height = pixelCrop.height;\r\n\r\n  // paste generated rotate image at the top left corner - BUT FIRST, clip to circle if needed\r\n  // For round crop, we apply a circular clip path\r\n  const centerX = pixelCrop.width / 2;\r\n  const centerY = pixelCrop.height / 2;\r\n  // Assuming aspect ratio is 1 for round crop, so width and height are the diameter\r\n  const radius = Math.min(pixelCrop.width, pixelCrop.height) / 2;\r\n\r\n  ctx.beginPath();\r\n  ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n  ctx.closePath();\r\n  ctx.clip();\r\n\r\n  // The data is for a rectangular area. To draw it into the circle,\r\n  // we might need to draw the original (rotated) image again, but positioned correctly for the clip.\r\n  // Or, more simply, put the rectangular data onto a temporary canvas\r\n  // and then draw that temporary canvas onto the clipped main canvas.\r\n\r\n  const tempCanvas = document.createElement('canvas');\r\n  tempCanvas.width = pixelCrop.width;\r\n  tempCanvas.height = pixelCrop.height;\r\n  const tempCtx = tempCanvas.getContext('2d');\r\n  if (!tempCtx) {\r\n    console.error('Failed to get 2D context from temporary canvas');\r\n    return null;\r\n  }\r\n  tempCtx.putImageData(data, 0, 0); // Place the rectangular crop data onto the temp canvas\r\n  \r\n  // Draw the content of the temporary canvas onto the main (circularly clipped) canvas\r\n  // This ensures the previously extracted rectangular data is now drawn within the circle clip\r\n  ctx.drawImage(tempCanvas, 0, 0, pixelCrop.width, pixelCrop.height);\r\n\r\n\r\n  // As a blob (which can then be turned into an object URL)\r\n  return new Promise((resolve, reject) => {\r\n    canvas.toBlob((file) => {\r\n      if (file) {\r\n        resolve(URL.createObjectURL(file));\r\n      }\r\n      else {\r\n        reject(new Error('Canvas is empty after attempting to draw cropped circular image.'));\r\n      }\r\n    }, 'image/png'); // Output as PNG to support transparency for the circular crop\r\n  });\r\n}\r\n\r\nexport function getRadianAngle(degreeValue) {\r\n  return (degreeValue * Math.PI) / 180;\r\n}\r\n\r\nexport function rotateSize(width, height, rotation) {\r\n  const rotRad = getRadianAngle(rotation);\r\n  return {\r\n    width:\r\n      Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\r\n    height:\r\n      Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\r\n  };\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}